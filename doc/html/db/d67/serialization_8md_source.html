<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fwdpp: md/serialization.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.5.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">md/serialization.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../db/d67/serialization_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Tutorial 3: Data serialization</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;## Intro</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;This tutorial covers the following topics:</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;* Writing simulated populations to files, and reading them back in</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;* Copying simulated population in memory</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;## The basic functions</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;For single-deme simulations, the library provides the following functions:</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;* KTfwd::write_binary_pop </div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;* KTfwd::read_binary_pop</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;These functions write and read simulated populations in a binary (_e.g._ not human-readable) format.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;For multi-deme simulations, we have:</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;* KTfwd::write_binary_metapop </div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;* KTfwd::read_binary_metapop</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;As with the rest of the library, these functions are implemented using a combination of templates + function overloading.</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;Currently, these functions support the following types of simulations:</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;* single-locus, single-deme</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;* single-locus, multi-deme</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;* multi-locus, single-deme</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;The type requirements for these functions are:</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;* Containers of objects used in fwdpp-based simulations (containers of gametes, mutations, diploids, etc.)</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;* Output streams compatible with the public interface of [std::ostream](http://www.cplusplus.com/reference/ostream/ostream/)</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;* Input streams compatible with the public interfact of [std::istream](http://www.cplusplus.com/reference/istream/istream/)</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;* Input via the gzFile type defined by [zlib](http://zlib.net)</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;## Writing and reading mutations</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;You need to tell these functions how to read/write mutation objects.  Specifically, you need to:</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;* Define a mutation write function, which takes a mutation object and an output stream type as an object.</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;* Define a mutation read function, taking an input stream type as an object</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;For a concrete example of implementing &quot;mutation readers&quot; and &quot;mutation writers&quot;, see the implementation of</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;KTfwd::mutation_writer and KTfwd::mutation_writer.</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;Below, you will see how to pass these to KTfwd::write_binary_pop and KTfwd::read_binary_pop.</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;## Reading and writing diploids.</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;Version 0.3.1 allowed the use of custom diploid genotype objects (@ref md_md_customdip).  Such objects can be serialized with no additional effort. _However, doing so will result in custom data associated with these custom types not being serialized._</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;In order to solve this, define your own custom structures for writing and reading:</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;struct diploid_writer {</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;   using result_type = void;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;   template&lt;typename dip_itr, typename streamtype &gt;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;   inline result_type( dip_itr i, streamtype &amp; o ) const</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;   {</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;           //Do the right thing here.</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;   }</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;};</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;~~~</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;The arguments should be an iterator pointing to one of your custom diploids, and a reference to an output stream (including a gzFile!).  A function object of the same form should also be written to read the data back in.</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;These custom serialization objects may be passed as the last arguments to the functions discussed in the next section.  By default, they are implicitly passed KTfwd::diploidIOplaceholder, which is essentially an empty object.</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;## In-memory copying</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;It may be desirable to be able to restore a population from a previous state.  For example, you may wish to repeatedly introduce a mutation at a position, and then simulate until it is fixed.  For replicates where it is lost, you will restore the population to the state it was in when you introduced the mutation.  You may do this using KTfwd::write_binary_pop  or KTfwd::write_binary_metapop, and write the population to an in-memory buffer such as [std::ostringstream](http://www.cplusplus.com/reference/sstream/ostringstream/).  You may restore the population by reading the data from a [std::istringstream](http://www.cplusplus.com/reference/sstream/istringstream/).</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;Here is some pseudocode for an single-deme simulation:</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;//run a simulation...</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;//write it to a buffer:</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;std::ostringstream buffer;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;KTfwd::write_binary_pop(gametes,mutations,diploids,std::bind(mwriter(),std::placeholders::_1,std::placeholders::_2),buffer);</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;//Now, if you want to restore it:</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;std::istringstream inbuffer(buffer.str());</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;decltype(mutations) mutations2;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;decltype(gametes) gametes2;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;decltype(diploids) diploids2;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;KTfwd::read_binary_pop(gametes2,</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                    mutations2,</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                    diploids2,</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                    std::bind(mreader(),std::placeholders::_1),</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                    inbuffer);</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;~~~</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;This approach works because KTfwd::write_binary_pop and KTfwd::write_binary_metapop perform &quot;deep copies&quot; of the data, allowing the complete restoration of all the pointers, etc., stored in the containers.</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;## Writing to files</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;You may use the same functions to write/read to from files.  You may use and sort of [std::ostream](http://www.cplusplus.com/reference/ostream/ostream/)-compatible object for output.  You may use either a [std::istream](http://www.cplusplus.com/reference/istream/istream/)-compatible object for input or a gzFile object from [zlib](http://zlib.net).</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;## Managing output from multiple independent processes</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;In practice, we often implement simulations with the idea that one replicate will be run per process, and that we will spread a large number of processes across our cluster.  Typically, we collect the output of these simulations into a single file.  To do this, we implement POSIX-style advisory file locking.  See [here](https://github.com/molpopgen/BigDataFormats) for a discussion of how to do that using the low-level C functions found in &lt;fcntl.h&gt;.   A more modern C++-based approach would be to use the [boost](http://www.boost.org) synchronization library.  See [here](https://gist.github.com/molpopgen/651e4ac81253f34364f7) for simple examples.</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;### Why not use boost serialization?</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;Cliff&#39;s notes version: this approach would work well for a single process writing lots of replicates to one file.  However, the archives that this library creates do not support appending on to an existing library.  This limitation is unfortunate, as being able to use this library would simplify some of the implementation.</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
